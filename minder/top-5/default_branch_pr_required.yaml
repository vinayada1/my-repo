version: v1
release_phase: beta
type: rule-type
name: default_branch_pr_required
display_name: Require pull requests for default branch changes
short_failure_message: Changes can be made to the default branch without a pull request
severity:
  value: high
context:
  provider: github
description: |
  Require that software changes are made through pull requests.  The pull request process
  provides hooks for human verification through code review and automated verification
  using CI processes.
guidance: |
  Enable a repository ruleset which requires that all changes to the
  specified branches (which includes at least the default branch) are made
  through pull requests.  Additionally, a ruleset should restrict force pushes
  and deletions of the specified branches, to prevent users rewriting the
  branch history.

  For more details on repository rulesets, see [GitHub's
  documentation](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/about-rulesets).
def:
  in_entity: repository
  rule_schema:
    properties:
      required_approvals:
        type: integer
        description: "The number of required approvals for pull requests."
        default: 0
  ingest:
    type: rest
    rest:
      endpoint: /graphql
      parse: json
      method: POST
      body: |
        { "query": "query {
          repository(name:\"{{.Entity.Name}}\", owner:\"{{.Entity.Owner}}\") {
            rulesets(first: 100) {
              nodes {
                id,
                name,
                databaseId,
                target,
                enforcement,
                conditions {
                  refName {exclude, include}
                },
                rules(first:100) {
                  nodes {type, parameters}
                }
              }
            }
          }
        }"}
  eval:
    type: rego
    rego:
      type: deny-by-default
      def: |
        package minder
        import rego.v1

        default allow := false
        default prs_required := false
        default force_push_blocked := false
        default delete_protected := false
        rulesets := input.ingested.data.repository.rulesets.nodes

        allow if {
          prs_required
          force_push_blocked
          delete_protected
        }

        message := sprintf(
          "Default branch protections missing:\n- Delete protected: %t\n- Force push protected: %t\n- PR required: %t",
          [delete_protected, force_push_blocked, prs_required])

        prs_required if {
          some ruleset
          rulesets[ruleset].target == "BRANCH"
          rulesets[ruleset].enforcement == "ACTIVE"
          matches_default_branch(rulesets[ruleset].conditions.refName.include)

          some rule
          rulesets[ruleset].rules.nodes[rule].type == "PULL_REQUEST"
          params := object.get(rulesets[ruleset].rules.nodes[rule], "parameters", {})
          required_reviews := object.get(params, "required_approving_review_count", 0)
          required_reviews >= input.profile.required_approvals
        }
        force_push_blocked if {
          some ruleset
          rulesets[ruleset].target == "BRANCH"
          rulesets[ruleset].enforcement == "ACTIVE"
          matches_default_branch(rulesets[ruleset].conditions.refName.include)

          some rule
          rulesets[ruleset].rules.nodes[rule].type == "NON_FAST_FORWARD"
        }

        delete_protected if {
          some ruleset
          rulesets[ruleset].target == "BRANCH"
          rulesets[ruleset].enforcement == "ACTIVE"
          matches_default_branch(rulesets[ruleset].conditions.refName.include)

          rulesets[ruleset].rules.nodes[rule].type == "DELETION"
        }

        default output := {"id": ""}
        # Two rules cannot share the same name; if we find a rule with
        # the target name, we should do an update rather than create
        output := {"id": ruleId} if {
          some ruleset
          rulesets[ruleset].name == "Enforce Pull Requests"
          ruleId := rulesets[ruleset].databaseId
        }

        # We can match the default branch three ways:
        matches_default_branch(refs) if {
          refs[_] == "~DEFAULT_BRANCH"
        }
        matches_default_branch(refs) if {
          refs[_] == concat("refs/heads/", input.properties["github/default_branch"])
        }
        matches_default_branch(refs) if {
          refs[_] == "~ALL"
        }
 
  remediate:
    type: rest
    rest:
      method: '{{if .EvalResultOutput.id}}PUT{{else}}POST{{end}}'
      endpoint: '/repos/{{.Entity.Owner}}/{{.Entity.Name}}/rulesets{{if .EvalResultOutput.id}}/{{.EvalResultOutput.id}}{{end}}'
      body: |
        {
          "name": "Enforce Pull Requests",
          "target": "branch",
          "enforcement": "active",
          "conditions": {
            "ref_name": {
              "include": ["~DEFAULT_BRANCH"],
              "exclude": []
            }
          },
          "rules": [
            {"type": "deletion"},
            {"type": "non_fast_forward"},
            {
              "type": "pull_request"
              {{if .Profile.required_approvals}}
              "parameters": {
                "required_approving_review_count": {{ .Profile.required_approvals }}
              },
              {{end}}
            }
          ]
        }
